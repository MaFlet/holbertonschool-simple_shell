man_1_simple_shell  "August 2024" Cohort_2024, Holberton School
Project C: Building our own simple shell

Name:
. Simple Shell (C Shell), - Operating command system,
UNIX command line interpreter.

Description:
. A Shell - acts like a commmand interpreter. The user inputs a
command after a prompt with a symbol like "$" that executes commands
to view set of files and directory within the operating system. It
is an interface of the operating system where control process when
created and searching different files and directories.

Synopsis:

. Interactive shell and Non-Interactive mode (Initial process to set
your own simple)

In the main.c file:

int main(void)
{

	signal(SIGINT, sigint_handler);

	if (isatty(STDIN_FILENO))
	{
		interactive_mode();
	}
	else
	{
		noninteractive_mode();
	}
	clean_up();

	return (0);
}
. SIGNIT is generated by CTRL + C (from keyboard) by the user to signal
termination of the program.

. isatty() function determine if the fd (file descriptor) is an open file
which is the terminal. It returns to 1 if the fd is process or referring to
a terminal 0 if otherwise, which in this case an interactive mode shell. A
fd is a unique process identification integer that handles an open file within
the operating shell system.

. isatty(STDIN_FILENO) including the isatty() function will check and test
whether there is an open file in the terminal and whether it is belonging to
the terminal.

. Interactive vs non-interactive why both?

. From its name itself, "interactive" is where the user inputs commands where
shell can execute whatever the user wants to see. 

. Example:

root@6c487c8d534f43c1af356748b4825b6b-2377118072:/holbertonschool-simple_shell# ./hsh
cisfun$ /bin/ls
AUTHORS     _strcspn.c  execute_command.c   man_1_simple_shell     tokenize_command.c
README.md   _strdup.c   find_path.c         noninteractive_mode.c
_getenv.c   _strlen.c   hsh                 read_command.c
_memmove.c  _strncmp.c  interactive_mode.c  shell
_strcmp.c   _strtrim.c  main.c              shell.h
cisfun$ 

. After displying the prompt (cisfun$), the user prompted a commmand that allows to
list all files and directories in the current directory. When user type and  prompted
with 'exit' it will terminate the program.

. Now what is a "Non-interactive" shell, it is still a processing shell but assuming
it does not interact with the user. However, it is CRITICAL to include the
non-interactive function for your simple shell. It also  handles the PATH environmental
variable (refer PATH variable on how to set and handle section), where its continually
look for executable commands in the background. It make sure to find the right commands
to excute without the user's interuption.

.Building processes for the basic functionality of a simple shell

Creating child process (Fork System)(refer to man 2 fork -  https://man7.org/linux/man-pages/man2/fork.2.html)

   The process starts when the user typed in a command like "/bin/ls" to list directories. Within, the shell
operating system, the parent process invokes a fork system call that split into children processes. Every child
process has its own unique number indicating a job or instructive process that is duplicate from the parent. "Access"
command is used to make sure the fork calling program has acccess to specific files in the system. "execve" command
checkes execuatble files to execute in the system's PATH environmental variable. The system wait is when the
parent awaits for its children to obtain the state of changes and obtain information before they terminate and then
the parent can finally execute. Example down below is a function to create child processes. 

- Example:

void execute_with_fork(char *command_path, char *argv[])
{
	pid_t pid; /*Initialising signed integer to represent a process ID*/
	int status; /*status of created child process*/

	if (access(command_path, X_OK) == 0) /*access command_path whehter its executable*/
	{
		pid = fork(); /*parent process invoking fork*/
		if (pid < 0) /*If fork failed*/
		{
			perror("fork failed"); /*it wil print error*/
			exit(EXIT_FAILURE); /*program will exit with failure status*/
		}
		if (pid == 0) /*if fork() returns to 0, its in child process*/
		{
			if (execve(command_path, argv, environ) == -1) /*child process will execute with execve replacing currrent
                                                                        executeble file with a new one specifed from command_path file*/
			{
				perror("Error with execve"); /*Returns -1 if fails and prints error*/
				exit(EXIT_FAILURE); /*exit child process with failure status*/
			}
		}
		else
			waitpid(pid, &status, 0); /*parent process have to wait for child's termination process*/
	}
	else
		fprintf(stderr, "Command does not exist: %s\n", command_path); /*if command is not executable, error message is printed*/
}  

Parsing the command

  Once the user types their commnad input, it will be tokenize. As /bin/ls will be split into /bin and /ls. The program will read the
tokenize commands and arguments, thus the program can understand as the user is trying to search and list directories - /ls within the
/bin directory containing executable files in the system.

  This can be achieved by using strtok() function. Example is down below:


void tokenize_command(char *command, char **argv)/*Syntax takes 2 parameters char *command (command string to be tokenize) and
{                                                 char **argv (array of pointers to store individual tokenize commands)*/
	int i = 0;/*Initializing i to go through array argv array*/
	char *token;/*Declaring char pointer for storing the address of tokenize commands*/

	token = strtok(command, " \t\n");/*Calling strtok() to tokenize 'command' beased on delimiters " \t\n" - space, tab, newline*/
	while (token != NULL && i < 63)/*Tokens are continually extracted through the while loop unti strtok() returns to NULL and i is 
	{                                is less than 63*/   
		argv[i++] = token;/*As the loop continues to store tokenize commands in argv array and i is incremented*/
		token = strtok(NULL, " \t\n");
	}
	argv[i] = NULL;/*argv is set to NULL to indicate that the loop finished*/
}

Handling environment PATH

  So how does the program search for list of files and directories throughout the system? surely there is a lot to go through. The PATH
environment variable is identified by a colon delimiter list of directories that contains executable files. This environment variable
sequentially looks for files and folders specified by PATH. If PATH is not set, files will not be found.

  Typing printrenv, prints the current environmental variable, notice value of PATH is printed: 

root@b21f996e61f149c088f06424fc6c24b1-2377118072:/holbertonschool-simple_shell# printenv
AWS_EXECUTION_ENV=AWS_ECS_FARGATE
AWS_CONTAINER_CREDENTIALS_RELATIVE_URI=/v2/credentials/57cb4457-7f96-4837-9e58-76917df0fb1d
HOSTNAME=b21f996e61f149c088f06424fc6c24b1-2377118072
AWS_DEFAULT_REGION=ap-southeast-2
AWS_REGION=ap-southeast-2
PWD=/holbertonschool-simple_shell
ECS_CONTAINER_METADATA_URI_V4=http://169.254.170.2/v4/b21f996e61f149c088f06424fc6c24b1-2377118072
HOME=/root
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
ECS_AGENT_URI=http://169.254.170.2/api/b21f996e61f149c088f06424fc6c24b1-2377118072
LESSCLOSE=/usr/bin/lesspipe %s %s
TERM=xterm-256color
LESSOPEN=| /usr/bin/lesspipe %s
ECS_CONTAINER_METADATA_URI=http://169.254.170.2/v3/b21f996e61f149c088f06424fc6c24b1-2377118072
SHLVL=1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin /*This indicates the shell which directory to search for executable files*/
_=/usr/bin/printenv
OLDPWD=/

  Once tokenize, the program will go through listed directories in the PATH. Take it the /ls command has been tokenize, the program will search
throughout the PATH that corresponds to /ls. Once executed it  results in listing the directories on stdout for the user to see. Below is the
example of function to find full path of given command throughtout listed directories of PATH:

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include "shell.h"

char *find_command_path(const char *command)
{
	char *path, *dir, *full_path;
	struct stat st;/*Define full information of file and defined to store information about file*/
	size_t len;/*Size type to specify size and lenght of string or command*/

	if (command[0] == '/' || command[0] == '.')/*Determines whether command starts with '/', indicating absolute path or '.', indicating
	{                                            relative path*/
		if (stat(command, &st) == 0 && (st.st_mode & S_IXUSR))/*Returns to duplicated string (as _strdup() call function), if file
			return (_strdup(command));                     is executable*/
		else
			return (NULL);
	}
	path = _getenv("PATH");/*Function to fetch PATH environment variable "PATH"*/
	if (!path)/*If PATH is not found return to NULL*/
		return (NULL);
	path = _strdup(path);/*PATH is duplicated from the original environment variable*/
	if (!path)/*If PATH cannot be duplicated..*/
	{
		perror("strdup failed");/*Print failed duplication and exit failure*/
		exit(EXIT_FAILURE);
	}
	dir = strtok(path, ":");/*Searching excutable files in colon-separated ":" directories, then proceed tokenizing*/
	while (dir)/*While loop to find executable files in the directory*/
	{
		len = _strlen(dir) + strlen(command) + 2;/*Calcualting length of string command for memory allocation*/
		full_path = malloc(len);/*Allocating full path commands*/
		if (!full_path)/*If full path is not allocated, print error and exit failure*/
		{
			perror("malloc failed"), exit(EXIT_FAILURE);
		}
		sprintf(full_path, "%s/%s", dir, command);/*sprint() function to store full_path*/
		if (stat(full_path, &st) == 0 && (st.st_mode & S_IXUSR))/*Checking status of executable commands*/
		{
			free(path);/*Free memory duplicated PATH*/
			return (full_path);
		}
		free(full_path);/*Free memory of full_path to avoid memory leaks*/
		dir = strtok(NULL, ":");
	}
	free(path);
	return (NULL);
} 

Helper functions:

    Every C files for this project have repetitive functions to perform common tasks like tokenizing, duplicating,
calculating string lengths, etc. Helper functions keep everything organized without adding all functions in one
big C file. It also assist the main C files (for example, find_path.c) to perform specific tasks. Below are the
helper function files for this project:

. _getenv.c = (Syntax: char *_getenv(const char *name)), getenv() function is used to get environment variables
with *name as representing the name of the variable. 

. _memmove.c = (Syntax: void *_memmove(void *dest, const void *src, size_t n)), it is important to implement
memmove() function in this project as it handles memory overlapping between the *src and *dest preventing it
for corrrupting the process. 

. _strcmp.c = (Syntax: int _strcmp(const char *s1, const char *s2)), strcmp() function compares between 2
strings. This is helpful when comparing between environment variables as the program requires to choose the
right variable to execute.

. _strcspn.c = (Syntax: size_t _strcspn(const char *s, const char *reject)), strcspn() work with tokenize string
segments. *s is th string that is scanned along the string *reject. The function calculates the length of *s and
determine whether there are characters that matches string *reject. The function returns to the index value 
of initial tokenize string of *s that is not found in *reject and length of *s if otherwise. This is a helpful
function, as it validates tokenize string, removing unwanted string characters.

. _strdup.c = (Syntax: char *_strdup(const char *s)), strdup() function is used to duplicate strings and then
allocate memory for the new duplicated string that has the same content of the original string. Since PATH
environment variables requires duplication, strdup is used for this. 

PLEASE NOTE: Since strdup() and Fork() relatively perfom duplicative processes, they entirely perform
independent and different processes. strdup() allow strings to be duplicated and both strings have the same
content. It allocate new strings in heap memory in blocks and copied strings will not affect the original
strings in the process. Creating child processes, is an independent process regarding execution and have
separate process ID's from the parent (calling) process. Child process is like a replica from the parent
process, once it terminates the operating system clean out its content and file descriptors.

. _strlen.c = (Syntax: size_t _strlen(const char *str)), strlen() function calulates entire string length
and returns the length with a size_t value. 

. _strncmp.c = (Syntax: int _strncmp(const chat *str1, const char *str2, size_t n)), strncmp() function
compare between 2 strings *str1 and *str2 up to 'n' characters. As size_t 'n' is the maximum number
of characters to compare. 

PLEASE NOTE: There is difference between strcmp and strncmp. As strcmp() function compare entire string
between *s1 and *s2 and returns an integer based on the comparison between 2 strings. Whilst, strncmp()
have 'n' representing as the maximum number of characters to compare between 2 strings. Therefore, it
is only specific number of characters can be compared. 

. _strtrim.c = (char *_strtrim(char *str)), strtrim() function      
