man_1_simple_shell  "August 2024" Cohort_2024, Holberton School
Project C: Building our own simple shell

Name:
. Simple Shell (C Shell), - Operating command system,
UNIX command line interpreter.

Description:
. A Shell - acts like a commmand interpreter. The user inputs a
command after a prompt with a symbol like "$" that executes commands
to view set of files and directory within the operating system. It
is an interface of the operating system where control process when
created and searching different files and directories.

Synopsis:

. Interactive shell and Non-Interactive mode (Initial process to set
your own simple)

In the main.c file:

int main(void)
{

	signal(SIGINT, sigint_handler);

	if (isatty(STDIN_FILENO))
	{
		interactive_mode();
	}
	else
	{
		noninteractive_mode();
	}
	clean_up();

	return (0);
}
. SIGNIT is generated by CTRL + C (from keyboard) by the user to signal
termination of the program.

. isatty() function determine if the fd (file descriptor) is an open file
which is the terminal. It returns to 1 if the fd is process or referring to
a terminal 0 if otherwise, which in this case an interactive mode shell. A
fd is a unique process identification integer that handles an open file within
the operating shell system.

. isatty(STDIN_FILENO) including the isatty() function will check and test
whether there is an open file in the terminal and whether it is belonging to
the terminal.

. Interactive vs non-interactive why both?

. From its name itself, "interactive" is where the user inputs commands where
shell can execute whatever the user wants to see. 

. Example:

root@6c487c8d534f43c1af356748b4825b6b-2377118072:/holbertonschool-simple_shell# ./hsh
cisfun$ /bin/ls
AUTHORS     _strcspn.c  execute_command.c   man_1_simple_shell     tokenize_command.c
README.md   _strdup.c   find_path.c         noninteractive_mode.c
_getenv.c   _strlen.c   hsh                 read_command.c
_memmove.c  _strncmp.c  interactive_mode.c  shell
_strcmp.c   _strtrim.c  main.c              shell.h
cisfun$ 

. After displying the prompt (cisfun$), the user prompted a commmand that allows to
list all files and directories in the current directory. When user type and  prompted
with 'exit' it will terminate the program.

. Now what is a "Non-interactive" shell, it is still a processing shell but assuming
it does not interact with the user. However, it is CRITICAL to include the
non-interactive function for your simple shell. It also  handles the PATH environmental
variable (refer PATH variable on how to set and handle section), where its continually
look for executable commands in the background. It make sure to find the right commands
to excute without the user's interuption.

.Building processes for the basic functionality of a simple shell

Creating child process (Fork System)(refer to man 2 fork -  https://man7.org/linux/man-pages/man2/fork.2.html)

   The process starts when the user typed in a command like "/bin/ls" to list directories. Within, the shell
operating system, the parent process invokes a fork system call that split into children processes. Every child
process has its own unique number indicating a job or instructive process that is duplicate from the parent. "Access"
command is used to make sure the fork calling program has acccess to specific files in the system. "execve" command
checkes execuatble files to execute in the system's PATH environmental variable. The system wait is when the
parent awaits for its children to obtain the state of changes and obtain information before they terminate and then
the parent can finally execute. Example down below is a function to create child processes. 

- Example:

void execute_with_fork(char *command_path, char *argv[])
{
	pid_t pid; /*Initialising signed integer to represent a process ID*/
	int status; /*status of created child process*/

	if (access(command_path, X_OK) == 0) /*access command_path whehter its executable*/
	{
		pid = fork(); /*parent process invoking fork*/
		if (pid < 0) /*If fork failed*/
		{
			perror("fork failed"); /*it wil print error*/
			exit(EXIT_FAILURE); /*program will exit with failure status*/
		}
		if (pid == 0) /*if fork() returns to 0, its in child process*/
		{
			if (execve(command_path, argv, environ) == -1) /*child process will execute with execve replacing currrent
                                                                        executeble file with a new one specifed from command_path file*/
			{
				perror("Error with execve"); /*Returns -1 if fails and prints error*/
				exit(EXIT_FAILURE); /*exit child process with failure status*/
			}
		}
		else
			waitpid(pid, &status, 0); /*parent process have to wait for child's termination process*/
	}
	else
		fprintf(stderr, "Command does not exist: %s\n", command_path); /*if command is not executable, error message is printed*/
}  

Parsing the command

  Once the user types their commnad input, it will be split into to
