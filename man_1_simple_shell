man_1_simple_shell  "August 2024" Cohort_2024, Holberton School
Project C: Building our own simple shell

Name:
. Simple Shell (C Shell), - Operating command system,
UNIX command line interpreter.

Description:
. A Shell - acts like a commmand interpreter. The user inputs a
command after a prompt with a symbol like "$" that executes commands
to view set of files and directory within the operating system. It
is an interface of the operating system where control process when
created and searching different files and directories.

Synopsis:

. Interactive shell and Non-Interactive mode (Initial process to set
your own simple)

In the main.c file:

int main(void)
{

	signal(SIGINT, sigint_handler);

	if (isatty(STDIN_FILENO))
	{
		interactive_mode();
	}
	else
	{
		noninteractive_mode();
	}
	clean_up();

	return (0);
}
. SIGNIT is generated by CTRL + C (from keyboard) by the user to signal
termination of the program.

. isatty() function determine if the fd (file descriptor) is an open file
which is the terminal. It returns to 1 if the fd is process or referring to
a terminal 0 if otherwise, which in this case an interactive mode shell. A
fd is a unique process identification integer that handles an open file within
the operating shell system.

. isatty(STDIN_FILENO) including the isatty() function will check and test
whether there is an open file in the terminal and whether it is belonging to
the terminal.

. Interactive vs non-interactive why both?

. From its name itself, "interactive" is where the user inputs commands where
shell can execute whatever the user wants to see. 

. Example:

root@6c487c8d534f43c1af356748b4825b6b-2377118072:/holbertonschool-simple_shell# ./hsh
cisfun$ /bin/ls
AUTHORS     _strcspn.c  execute_command.c   man_1_simple_shell     tokenize_command.c
README.md   _strdup.c   find_path.c         noninteractive_mode.c
_getenv.c   _strlen.c   hsh                 read_command.c
_memmove.c  _strncmp.c  interactive_mode.c  shell
_strcmp.c   _strtrim.c  main.c              shell.h
cisfun$ 

. After displying the prompt (cisfun$), the user prompted a commmand that allows to
list all files and directories in the current directory. When user type and  prompted
with 'exit' it will terminate the program.

. Now what is a "Non-interactive" shell, it is still a processing shell but assuming
it does not interact with the user. However, it is CRITICAL to include the
non-interactive function for your simple shell. It also  handles the PATH environmental
variable (refer PATH variable on how to set and handle section), where its continually
look for executable commands in the background. It make sure to find the right commands
to excute without the user's interuption.

.Building processes for the basic functionality of a simple shell

Creating child process (Fork System)(refer to man 2 fork -  https://man7.org/linux/man-pages/man2/fork.2.html)

   The process starts when the user typed in a command like "/bin/ls" to list directories. Within, the shell
operating system, the parent process invokes a fork system call that split into children processes. Every child
process has its own unique number indicating a job or instructive process that is duplicate from the parent. "Access"
command is used to make sure the fork calling program has acccess to specific files in the system. "execve" command
checkes execuatble files to execute in the system's PATH environmental variable. The system wait is when the
parent awaits for its children to obtain the state of changes and obtain information before they terminate and then
the parent can finally execute. Example down below is a function to create child processes. 

- Example:

void execute_with_fork(char *command_path, char *argv[])
{
	pid_t pid; /*Initialising signed integer to represent a process ID*/
	int status; /*status of created child process*/

	if (access(command_path, X_OK) == 0) /*access command_path whehter its executable*/
	{
		pid = fork(); /*parent process invoking fork*/
		if (pid < 0) /*If fork failed*/
		{
			perror("fork failed"); /*it wil print error*/
			exit(EXIT_FAILURE); /*program will exit with failure status*/
		}
		if (pid == 0) /*if fork() returns to 0, its in child process*/
		{
			if (execve(command_path, argv, environ) == -1) /*child process will execute with execve replacing currrent
                                                                        executeble file with a new one specifed from command_path file*/
			{
				perror("Error with execve"); /*Returns -1 if fails and prints error*/
				exit(EXIT_FAILURE); /*exit child process with failure status*/
			}
		}
		else
			waitpid(pid, &status, 0); /*parent process have to wait for child's termination process*/
	}
	else
		fprintf(stderr, "Command does not exist: %s\n", command_path); /*if command is not executable, error message is printed*/
}  

Parsing the command

  Once the user types their commnad input, it will be tokenize. As /bin/ls will be split into /bin and /ls. The program will read the
tokenize commands and arguments, thus the program can understand as the user is trying to search and list directories - /ls within the
/bin directory containing executable files in the system.

  This can be achieved by using strtok() function. Example is down below:


void tokenize_command(char *command, char **argv)/*Syntax takes 2 parameters char *command (command string to be tokenize) and
{                                                 char **argv (array of pointers to store individual tokenize commands)*/
	int i = 0;/*Initializing i to go through array argv array*/
	char *token;/*Declaring char pointer for storing the address of tokenize commands*/

	token = strtok(command, " \t\n");/*Calling strtok() to tokenize 'command' beased on delimiters " \t\n" - space, tab, newline*/
	while (token != NULL && i < 63)/*Tokens are continually extracted through the while loop unti strtok() returns to NULL and i is 
	{                                is less than 63*/   
		argv[i++] = token;/*As the loop continues to store tokenize commands in argv array and i is incremented*/
		token = strtok(NULL, " \t\n");
	}
	argv[i] = NULL;/*argv is set to NULL to indicate that the loop finished*/
}

Handling environment PATH

  So how does the program search for list of files and directories throughout the system? surely there is a lot to go through. The PATH
environment variable is identified by a colon delimiter list of directories that contains executable files. This environment variable
sequentially looks for files and folders specified by PATH. If PATH is not set, files will not be found.

  Typing printrenv, prints the current environmental variable, notice value of PATH is printed: 

root@b21f996e61f149c088f06424fc6c24b1-2377118072:/holbertonschool-simple_shell# printenv
AWS_EXECUTION_ENV=AWS_ECS_FARGATE
AWS_CONTAINER_CREDENTIALS_RELATIVE_URI=/v2/credentials/57cb4457-7f96-4837-9e58-76917df0fb1d
HOSTNAME=b21f996e61f149c088f06424fc6c24b1-2377118072
AWS_DEFAULT_REGION=ap-southeast-2
AWS_REGION=ap-southeast-2
PWD=/holbertonschool-simple_shell
ECS_CONTAINER_METADATA_URI_V4=http://169.254.170.2/v4/b21f996e61f149c088f06424fc6c24b1-2377118072
HOME=/root
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
ECS_AGENT_URI=http://169.254.170.2/api/b21f996e61f149c088f06424fc6c24b1-2377118072
LESSCLOSE=/usr/bin/lesspipe %s %s
TERM=xterm-256color
LESSOPEN=| /usr/bin/lesspipe %s
ECS_CONTAINER_METADATA_URI=http://169.254.170.2/v3/b21f996e61f149c088f06424fc6c24b1-2377118072
SHLVL=1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin /*This indicates the shell which directory to search for executable files*/
_=/usr/bin/printenv
OLDPWD=/

  Setting the PATH environment variable is 
