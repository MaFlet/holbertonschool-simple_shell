man_1_simple_shell  "August 2024" Cohort_2024, Holberton School, 
Project C: Building our own simple shell

NAME:

@Simple Shell (C Shell), - Operating System, UNIX command line interpreter.


DESCRIPTION:

@Shell is an UNIX Operating System that takes in command inputs from the user.
The user inputs a command after a prompt after a symbol like "$", like for
example /bin/ls, it will list a set of files and directory within the directory
bin. It is an interface of the operating system where control processes where
created.


HOW TO MAKE A SIMPLE SHELL?

@Building your own simple shell from scratch is like looking at a blank piece
of paper. Here are some of the main functions that help us establish our own
simple shell.

.Interactive and Non-Interactive mode (Initial process to set your own simple)

->In the main.c file:

int main(void)
{

	signal(SIGINT, sigint_handler);

	if (isatty(STDIN_FILENO))
	{
		interactive_mode();
	}
	else
	{
		noninteractive_mode();
	}
	clean_up();

	return (0);
}

.SIGNIT is generated by CTRL + C (from keyboard) by the user to signal
termination of the program.

.isatty() function determine if the fd (file descriptor) is an open file
which makes terminal system fucntional. It returns to 1 if the fd is a process
or referring to a terminal and 0 if otherwise - which in this case an 
interactive mode shell. A fd is a unique process identification integer that
handles an open file within the operating shell system.

.isatty(STDIN_FILENO), will check and test whether there is an open file in the
terminal and whether it is belonging to the terminal.


INTERACTIVE vs NON-INTERACTIVE, WHY BOTH?

@From the name itself, "interactive" is where the user inputs commands that
shell can execute whatever the user wants to see. 

->Example:

root@6c487c8d534f43c1af356748b4825b6b:/holbertonschool-simple_shell# ./hsh
cisfun$ /bin/ls
AUTHORS     _strcspn.c  execute_command.c   man_1_simple_shell     tokenize_command.c
README.md   _strdup.c   find_path.c         noninteractive_mode.c
_getenv.c   _strlen.c   hsh                 read_command.c
_memmove.c  _strncmp.c  interactive_mode.c  shell
_strcmp.c   _strtrim.c  main.c              shell.h
cisfun$ 

@After displying the prompt (cisfun$), the user is  prompted to type in a
commmand - /bin/ls which that allows the user to see list of files and
directories in bin. When user type 'exit' after prompt, it will terminate the
program.

@Now what is a "Non-interactive" shell? It is still a processing shell but assuming
it does not interact with the user. However, it is CRITICAL to include the
non-interactive function for your simple shell. It also handles the PATH
environmental variable, where it continually look for executable commands in the
background. It ensures to find the right commands to excute without the user's
interuption.

HOW TO PRINT A PROMPT FOR USER TO TYPE COMMANDS?

@The getline function is used to read the user's input command (from input
stream). It reads whole input including spaces. This function need to be in a
loop in order for the prompt to be printed continuously for the user to input
commands.

->Example extracted code (read_command.c file):

if (interactive)
		printf("cisfun$ "); /*prints prompt that will show in stdin*/
	input = getline(&command_buffer, &bufsize, stdin); /*getline dynamically allocates buffer to read line in stdin*/


BUILDING PROCESSES FOR THE BASIC FUNCTIONALITY OF A SIMPLE SHELL

@Creating child process (Fork System)

.The process starts when the user typed in a command like "/bin/ls". Within
the shell operating system, the parent process invokes a fork system call that
split into children processes. Every child process has its own unique number
indicating a job or instructive process that is a duplicate from the parent.
"Access" command is used to make sure the fork calling program has acccess to
specific files in the system. "execve" command checks execuatble files to
execute in the system's PATH environmental variable. The system wait, is when
the parent awaits for its children to obtain their state of changes and obtain
their information before they terminate and then the parent can finally execute.
Example down below is a function to create child processes. 

->Example:

void execute_with_fork(char *command_path, char *argv[])
{
	pid_t pid; /*Initialising signed integer to represent a process ID*/
	int status; /*status of created child process*/

	if (access(command_path, X_OK) == 0) /*access command_path whether its executable*/
	{
		pid = fork(); /*parent process invoking fork*/
		if (pid < 0) /*If fork failed*/
		{
			perror("fork failed"); /*it will print error*/
			exit(EXIT_FAILURE); /*program will exit with failure status*/
		}
		if (pid == 0) /*if fork() returns to 0, its in child process*/
		{
			if (execve(command_path, argv, environ) == -1) /*child process will execute with execve, replacing currrent
                                                                        executeble file with a new one specifed from command_path file*/
			{
				perror("Error with execve"); /*Returns -1 if fails and prints error*/
				exit(EXIT_FAILURE); /*exit child process with failure status*/
			}
		}
		else
			waitpid(pid, &status, 0); /*parent process have to wait for child's termination process*/
	}
	else
		fprintf(stderr, "Command does not exist: %s\n", command_path); /*if command is not executable, error message is printed*/
}


PARSING THE COMMAND

@Once the user types their commnad input, it will be tokenize. As /bin/ls will
be split into /bin and /ls. The program will read the tokenize commands and
arguments. Piece by piece, the program can recognise user's intention to list
directories "/ls" that is contained in the "/bin" directory of which also
contain executable files in the system.

.This can be achieved by using strtok() function. Example is down below:

void tokenize_command(char *command, char **argv) /*Syntax takes 2 parameters *command (command string to be tokenize) and
{                                                 **argv (array of pointers to store individual tokenize commands)*/
	int i = 0; /*Initialize i to go through argv array*/
	char *token; /*Declaring char pointer for storing the address of tokenize commands*/

	token = strtok(command, " \t\n"); /*Calling strtok() to tokenize 'command' based on delimiters " \t\n" - space, tab, newline*/
	while (token != NULL && i < 63) /*Tokens are continually extracted through the while loop until strtok() returns to NULL and i is 
	{                                is less than 63*/   
		argv[i++] = token; /*As the loop continues to store tokenize commands in argv array and i is incremented*/
		token = strtok(NULL, " \t\n");
	}
	argv[i] = NULL; /*argv is set to NULL to indicate that the loop finished*/
}


HANDLING ENVIRONMENT PATH

@So how does the program search for list of files and directories throughout the
system? surely there is a lot to go through. The PATH environment variable is
identified by a colon delimiter ":" with name of directories that contains
executable files. This environment variable sequentially looks for files and
folders specified by PATH. If PATH is not set, files will not be found.

.Typing printenv, prints the current environmental variable, NOTICE the  value
of PATH is printed: 

root@b21f996e61f149c088f06424fc6c24b1:/holbertonschool-simple_shell# printenv
AWS_EXECUTION_ENV=AWS_ECS_FARGATE
AWS_CONTAINER_CREDENTIALS_RELATIVE_URI=/v2/credentials/57cb4457-7f96-4837-9e58-
76917df0fb1d
HOSTNAME=b21f996e61f149c088f06424fc6c24b1-2377118072
AWS_DEFAULT_REGION=ap-southeast-2
AWS_REGION=ap-southeast-2
PWD=/holbertonschool-simple_shell
ECS_CONTAINER_METADATA_URI_V4=http://169.254.170.2/v4/b21f996e61f149c088f06424f
c6c24b1-2377118072
HOME=/root
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:c
d=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37
;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=
01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:
*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:
*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01
;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.e
ar=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;
31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=
01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;
35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.ti
f=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;
35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.
webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01
;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.a
vi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:
*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00
;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*
.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00
;36:*.xspf=00;36:
ECS_AGENT_URI=http://169.254.170.2/api/b21f996e61f149c088f06424fc6c24b1-2377118
072
LESSCLOSE=/usr/bin/lesspipe %s %s
TERM=xterm-256color
LESSOPEN=| /usr/bin/lesspipe %s
ECS_CONTAINER_METADATA_URI=http://169.254.170.2/v3/b21f996e61f149c088f06424fc6c
24b1-2377118072
SHLVL=1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin /*This indicates the shell which directory to search for executable files*/
_=/usr/bin/printenv
OLDPWD=/

@Once tokenize, the program will go through listed directories in the PATH. Take
it the /ls command has been tokenize, the program will search throughout the
PATH that corresponds to /ls. Once executed it results in listing the
directories on stdout for the user to see. Below is the example of function to
find full path of given command throughout listed directories of PATH:

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include "shell.h"

char *find_command_path(const char *command)
{
	char *path, *dir, *full_path;
	struct stat st; /*Define full information of file and store information about file*/
	size_t len; /*Size type to specify size and length of string or command*/

	if (command[0] == '/' || command[0] == '.') /*Determines whether command starts with '/', indicating absolute path or '.', indicating
	{                                            relative path*/
		if (stat(command, &st) == 0 && (st.st_mode & S_IXUSR)) /*Returns to duplicated string (as _strdup() call function), if file
			return (_strdup(command));                     is executable*/
		else
			return (NULL);
	}
	path = _getenv("PATH"); /*Function to fetch PATH environment variable "PATH"*/
	if (!path) /*If PATH is not found return to NULL*/
		return (NULL);
	path = _strdup(path); /*PATH is duplicated from the original environment variable*/
	if (!path) /*If PATH cannot be duplicated..*/
	{
		perror("strdup failed"); /*Print failed duplication and exit failure*/
		exit(EXIT_FAILURE);
	}
	dir = strtok(path, ":"); /*Searching excutable files in colon-separated ":" directories, then proceed tokenizing*/
	while (dir) /*While loop to find executable files in the directory*/
	{
		len = _strlen(dir) + strlen(command) + 2; /*Calcualting length of string command for memory allocation*/
		full_path = malloc(len); /*Allocating full path commands*/
		if (!full_path) /*If full path is not allocated, print error and exit failure*/
		{
			perror("malloc failed"), exit(EXIT_FAILURE);
		}
		sprintf(full_path, "%s/%s", dir, command); /*sprint() function to store full_path*/
		if (stat(full_path, &st) == 0 && (st.st_mode & S_IXUSR)) /*Checking status of executable commands*/
		{
			free(path); /*Free memory duplicated PATH*/
			return (full_path);
		}
		free(full_path); /*Free memory of full_path to avoid memory leaks*/
		dir = strtok(NULL, ":");
	}
	free(path);
	return (NULL);
} 


HELPER FUNCTIONS

    Every C files for this project have repetitive functions to perform common tasks like tokenizing, duplicating,
calculating string lengths, etc. Helper functions keep everything organized without adding all functions in one
big C file. It also assist the main C files (for example, find_path.c) to perform specific tasks. Below are the
helper function files for this project:

. _getenv.c = (Syntax: char *_getenv(const char *name)), getenv() function is used to get environment variables
with *name as representing the name of the variable. 

. _memmove.c = (Syntax: void *_memmove(void *dest, const void *src, size_t n)), it is important to implement
memmove() function in this project as it handles memory overlapping between the *src and *dest preventing it
for corrrupting the process. 

. _strcmp.c = (Syntax: int _strcmp(const char *s1, const char *s2)), strcmp() function compares between 2
strings. This is helpful when comparing between environment variables as the program requires to choose the
right variable to execute.

. _strcspn.c = (Syntax: size_t _strcspn(const char *s, const char *reject)), strcspn() work with tokenize string
segments. *s is th string that is scanned along the string *reject. The function calculates the length of *s and
determine whether there are characters that matches string *reject. The function returns to the index value 
of initial tokenize string of *s that is not found in *reject and length of *s if otherwise. This is a helpful
function, as it validates tokenize string, removing unwanted string characters.

. _strdup.c = (Syntax: char *_strdup(const char *s)), strdup() function is used to duplicate strings and then
allocate memory for the new duplicated string that has the same content of the original string. Since PATH
environment variables requires duplication, strdup is used for this. 

PLEASE NOTE: Since strdup() and Fork() relatively perfom duplicative processes, they entirely perform
independent and different processes. strdup() allow strings to be duplicated and both strings have the same
content. It allocate new strings in heap memory in blocks and copied strings will not affect the original
strings in the process. Creating child processes, is an independent process regarding execution and have
separate process ID's from the parent (calling) process. Child process is like a replica from the parent
process, once it terminates the operating system clean out its content and file descriptors.

. _strlen.c = (Syntax: size_t _strlen(const char *str)), strlen() function calulates entire string length
and returns the length with a size_t value. 

. _strncmp.c = (Syntax: int _strncmp(const chat *str1, const char *str2, size_t n)), strncmp() function
compare between 2 strings *str1 and *str2 up to 'n' characters. As size_t 'n' is the maximum number
of characters to compare. 

PLEASE NOTE: There is difference between strcmp and strncmp. As strcmp() function compare entire string
between *s1 and *s2 and returns an integer based on the comparison between 2 strings. Whilst, strncmp()
have 'n' representing as the maximum number of characters to compare between 2 strings. Therefore, it
is only specific number of characters can be compared. 

. _strtrim.c = (char *_strtrim(char *str)), as we tokenize string commands it can lead to trailing
whitespaces and that needs to be dealt with. strtrim() function allows *str pointer to lead and point
to the initial string (non-whitespace) character. The function will return to str, that points to the
trimmed string.

.AUTHORS
.Chutima Puthachon, Xi Qern Egan Leong, Mary Ruth G. Fletcher      
